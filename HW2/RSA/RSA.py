from gmpy2 import next_prime, mpz
from Crypto.Util.number import *

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

def getN(p):
    q1 = next_prime(2 * p)
    q2 = next_prime(3 * q1)
    return p * q1 * q2

def nextP(p, n):
    delta = (n - getN(p)) // (p * p)
    if delta < 100:
        delta = 100
    return p + delta // 100

def getP(n):
    p = int(pow(n / 12, 1 / 3))
    while getN(p) != n:
        p = nextP(p, n)
        if getN(p) > n:
            p -= 100
    return p

def getD(p, e):
    q1 = next_prime(2 * p)
    q2 = next_prime(3 * q1)
    r = (p - 1) * (q1 - 1) * (q2 - 1)
    d = modinv(e, r)
    return d

n = 22001778874542774315484392481115711539281104740723517828461360611903057304469869336789715900703500619163822273767393143914615001907123143200486464636351989898613180095341102875678204218769723325121832871221496816486100959384589443689594053640486953989205859492780929786509801664036223045197702752965199575588498118481259145703054094713019549136875163271600746675338534685099132138833920166786918380439074398183268612427028138632848870032333985485970488955991639327
c = 1067382668222320523824132555613324239857438151855225316282176402453660987952614935478188752664288189856467574123997124118639803436040589761488611318906877644244524931837804614243835412551576647161461088877884786181205274671088951504353502973964810690277238868854693198170257109413583371510824777614377906808757366142801309478368968340750993831416162099183649651151826983793949933939474873893278527484810417812120138131555544749220438456366110721231219155629863865
e = 65537

flag = int(pow(c, getD(getP(mpz(n)), e), n)).to_bytes(192, byteorder="big")
pos = 0
for i in range(len(flag)):
    if flag[i] == 0:
        pos = i + 1
flag = flag[pos:].decode()
print(flag)

